<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>2D Reordering</title>
<style>
    body {
        background:#111;
        color:#eee;
        font-family:sans-serif;
        padding:2rem;
        display:flex;
        flex-direction:column;
        align-items:center;
    }

    #grid {
        display:grid;
        grid-template-columns:repeat(auto-fill,minmax(80px,1fr));
        gap:12px;
        width:100%;
        max-width:520px;
        position:relative;
    }

    .item {
        background:#222;
        border:1px solid #444;
        border-radius:8px;
        padding:1.5rem 0;
        text-align:center;
        font-size:1.2rem;
        user-select:none;
        cursor:grab;
        transition:transform 165ms ease;
        position:relative;
    }

    .item.drag-src {
        opacity:0.25;
    }

    .floating {
        position:fixed;
        background:#fff;
        color:#000;
        width:80px;
        padding:1.5rem 0;
        border-radius:8px;
        border:2px solid #fff;
        pointer-events:none;
        font-size:1.2rem;
        text-align:center;
        transform:translate(-50%,-50%);
        z-index:9999;
    }
</style>
</head>

<body>

<h2>NUNYA.BIZ HOME</h2>

<div id="grid">
    <div class="item">1</div><div class="item">2</div><div class="item">3</div>
    <div class="item">4</div><div class="item">5</div><div class="item">6</div>
    <div class="item">7</div><div class="item">8</div><div class="item">9</div>
    <div class="item">10</div><div class="item">11</div><div class="item">12</div>
</div>

<script>
(function(){

    const grid = document.getElementById("grid");
    let items = [...grid.children];

    let originalRects = [];
    let dragging = null;
    let floating = null;
    let startIndex = -1;

    // -----------------------------------------------
    // Capture rects of *original layout* (stable forever)
    // -----------------------------------------------
    function captureOriginalRects() {
        originalRects = items.map(el => {
            const r = el.getBoundingClientRect();
            return {
                left: r.left,
                top: r.top,
                w: r.width,
                h: r.height,
                cx: r.left + r.width/2,
                cy: r.top + r.height/2
            };
        });
    }

    // -----------------------------------------------
    // Find nearest index by stable rect centers
    // -----------------------------------------------
    function nearestIndex(x, y) {
        let best = 0;
        let bestDist = Infinity;
        for (let i = 0; i < originalRects.length; i++) {
            const r = originalRects[i];
            const dx = r.cx - x;
            const dy = r.cy - y;
            const d = dx*dx + dy*dy;
            if (d < bestDist) {
                bestDist = d;
                best = i;
            }
        }
        return best;
    }

    // -----------------------------------------------
    // Re-render transforms based on virtual ordering
    // -----------------------------------------------
    function applyTransforms() {
        for (let i = 0; i < items.length; i++) {
            const el = items[i];
            const targetRect = originalRects[i];
            const currentRect = el.__origPos; // from start capture
            const dx = targetRect.left - currentRect.left;
            const dy = targetRect.top  - currentRect.top;
            el.style.transform = `translate(${dx}px, ${dy}px)`;
        }
    }

    // -----------------------------------------------
    // Pointer events
    // -----------------------------------------------
    grid.addEventListener("pointerdown", e => {
        const t = e.target.closest(".item");
        if (!t) return;

        e.preventDefault();

        dragging = t;
        startIndex = items.indexOf(dragging);

        // Capture *once* (critical fix)
        captureOriginalRects();
        items.forEach((el, i) => {
            const r = el.getBoundingClientRect();
            el.__origPos = {left:r.left, top:r.top};
        });

        // Floating clone
        floating = dragging.cloneNode(true);
        floating.classList.remove("item");
        floating.classList.add("floating");
        document.body.appendChild(floating);

        dragging.classList.add("drag-src");
        dragging.setPointerCapture(e.pointerId);

        moveFloating(e);
    });

    grid.addEventListener("pointermove", e => {
        if (!dragging) return;
        moveFloating(e);

        const idx = nearestIndex(e.clientX, e.clientY);
        if (idx === startIndex) return;

        // reorder the items array
        const removed = items.splice(startIndex,1)[0];
        items.splice(idx,0,removed);
        startIndex = idx;

        // Now apply transforms: each DOM element moves to the slot
        // determined by its index in items[].
        // The transforms are computed against originalRects[].
        for (let i=0; i<items.length; i++) {
            const el = items[i];
            const tr = originalRects[i];
            const or = el.__origPos;
            const dx = tr.left - or.left;
            const dy = tr.top  - or.top;
            el.style.transform = `translate(${dx}px, ${dy}px)`;
        }
    });

    grid.addEventListener("pointerup", e => {
        if (!dragging) return;

        dragging.releasePointerCapture(e.pointerId);

        floating.remove();
        floating = null;

        dragging.classList.remove("drag-src");

        // Commit DOM order
        items.forEach(el => {
            el.style.transform = "";
            grid.appendChild(el);
        });

        dragging = null;
        startIndex = -1;
    });

    function moveFloating(e) {
        floating.style.left = e.clientX + "px";
        floating.style.top  = e.clientY + "px";
    }

})();
</script>

</body>
</html>
